/*terminali*/
terminal VAR, COLON, ASSIGN, SEMI, COMMA, REAL, INTEGER, STRING, BOOLEAN, RETURN, FUNCTION, TYPERETURN,
    ENDFUNCTION, LPAR, RPAR, PROCEDURE, ENDPROCEDURE, OUT, WRITE, WRITERETURN, DOLLARSIGN, READ, IF, THEN, ELSE, ENDIF,
    ELIF, WHILE, DO, ENDWHILE, PLUS, MINUS, TIMES, DIV, EQ, NE, LT, LE, GT, GE, AND, OR, NOT, ENDVAR, REF, UMINUS;

terminal String ID, STRING_CONST;
terminal Double REAL_CONST;
terminal Integer INTEGER_CONST;
terminal Boolean TRUE, FALSE;

/*non terminali*/
non terminal Program, Iter, Procedure, VarDecl, Function, Decls, Ids, Type,Const, Consts, FuncParams, Types, Body,
    OtherFuncParams, ProcParams,OtherProcParams, ProcParamId, Stat, ProcCall,FunCall, IOArgs, IfStat, WhileStat, Exprs,
    Elif, ProcExprs, Elifs, Expr, Else;



/*PRECEDENZE*/

precedence nonassoc PROCEDURE;

precedence right ASSIGN; // x=y=3 diventa x=(y=3)

precedence left DOLLARSIGN;

precedence left OR;
precedence left AND;

//gli operatori di confronto non hanno associatività (non è possibile fare x<=y<=z)
precedence nonassoc EQ,NE,LT,LE,GT,GE;

precedence left PLUS, MINUS;
precedence left TIMES, DIV;

precedence right NOT;
precedence left UMINUS;


precedence right REF;

precedence left LPAR,RPAR;



  Program ::= Iter Procedure Iter;

  Iter ::= VarDecl Iter
        | Function Iter
        | Procedure Iter
        | /* empty */;

  VarDecl ::= VAR Decls;

  Decls ::= Ids COLON Type SEMI Decls
  	| Ids ASSIGN Consts SEMI Decls
  	| Ids COLON Type SEMI ENDVAR
  	| Ids ASSIGN Consts SEMI ENDVAR;

  Ids ::= ID COMMA Ids
          | ID;

  Consts ::= Const COMMA Consts
  	| Const;

  Const ::= REAL_CONST
  	| INTEGER_CONST
  	| STRING_CONST
  	| TRUE
  	| FALSE;

  Type ::= REAL
  	| INTEGER
  	| STRING
  	| BOOLEAN;

  Function  ::= FUNCTION ID LPAR FuncParams RPAR TYPERETURN Types COLON Body ENDFUNCTION;

  FuncParams ::= ID COLON Type OtherFuncParams
  	    | /* empty */;

  OtherFuncParams ::= COMMA ID COLON Type OtherFuncParams
  	    | /* empty */;

  Types ::= Type COMMA Types
  	| Type;

  Procedure ::= PROCEDURE ID LPAR ProcParams RPAR COLON Body ENDPROCEDURE;

  ProcParams::= ProcParamId COLON Type OtherProcParams
  	   | /* empty */;

  OtherProcParams ::= COMMA ProcParamId COLON Type OtherProcParams
  	   | /* empty */;

  ProcParamId ::= ID
  	    | OUT ID;

  Body ::= VarDecl Body
  	| Stat Body
  	| /* empty */;

  Stat ::= Ids ASSIGN Exprs SEMI
  	 | ProcCall  SEMI
  	 | RETURN Exprs SEMI
  	 | WRITE IOArgs SEMI
  	 | WRITERETURN IOArgs SEMI
  	 | READ IOArgs SEMI
  	 | IfStat SEMI
  	 | WhileStat SEMI;

  FunCall ::= ID LPAR Exprs RPAR           /* chiamata con almeno un parametro */
           | ID LPAR RPAR;                 /* chiamata con nessun parametro */

  ProcCall ::= ID LPAR ProcExprs RPAR    /* chiamata con almeno un parametro */
           | ID LPAR RPAR;             /* chiamata con nessun parametro */

  IfStat ::= IF Expr THEN Body Elifs Else ENDIF;

  Elifs ::= Elif Elifs
        | /* empty */;

  Elif ::= ELIF Expr THEN Body;

  Else ::= ELSE Body
       | /* empty */;

  WhileStat ::= WHILE Expr DO Body ENDWHILE;

  IOArgs ::= Expr IOArgs    /* qui l'Expr corretta è concatenazione di stringhe o singola stringa*/
         |  DOLLARSIGN LPAR Expr RPAR IOArgs
         | /* empty */;

  ProcExprs::= Expr COMMA ProcExprs
  	  | REF ID COMMA ProcExprs
      | Expr
  	  | REF ID;

  Exprs ::= Expr COMMA Exprs
  	| Expr;


  Expr ::= FunCall
  	| REAL_CONST
    | INTEGER_CONST
  	| STRING_CONST
  	| ID
    | TRUE
    | FALSE
    | Expr:e1  PLUS Expr:e2 {:RESULT = e1+e2; :}
  	| Expr:e1  MINUS Expr:e2 {:RESULT = e1-e2; :}
  	| Expr:e1  TIMES Expr:e2 {:RESULT = e1*e2; :}
  	| Expr:e1  DIV Expr:e2 {:RESULT = e1/e2; :}
  	| Expr:e1  AND Expr:e2 {:RESULT = e1&&e2; :}
  	| Expr:e1  OR Expr:e2 {:RESULT = e1||e2; :}
  	| Expr:e1  GT Expr:e2 {:RESULT = e1>e2; :}
  	| Expr:e1  GE Expr:e2 {:RESULT = e1>=e2; :}
  	| Expr:e1  LT Expr:e2 {:RESULT = e1<e2; :}
  	| Expr:e1  LE Expr:e2 {:RESULT = e1<=e2; :}
  	| Expr:e1  EQ Expr:e2 {:RESULT = e1=e2; :}
  	| Expr:e1  NE Expr:e2 {:RESULT = e1!=e2; :}
  	| LPAR Expr RPAR
  	| MINUS Expr:e {:RESULT = -e; :}
  	    %prec UMINUS
  	| NOT Expr:e {:RESULT = !e; :};