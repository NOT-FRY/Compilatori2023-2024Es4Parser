/*terminali*/
terminal VAR, COLON, ASSIGN, SEMI, COMMA, REAL, INTEGER, STRING, BOOLEAN, RETURN, FUNCTION, TYPERETURN,
    ENDFUNCTION, LPAR, RPAR, PROCEDURE, ENDPROCEDURE, OUT, WRITE, WRITERETURN, DOLLARSIGN, READ, IF, THEN, ELSE, ENDIF,
    ELIF, WHILE, DO, ENDWHILE, PLUS, MINUS, TIMES, DIV, EQ, NE, LT, LE, GT, GE, AND, OR, NOT, ENDVAR, REF, UMINUS;

terminal String ID, STRING_CONST;
terminal Double REAL_CONST;
terminal Integer INTEGER_CONST;
terminal Boolean TRUE, FALSE;

/*non terminali*/
non terminal Program, Iter, Procedure, VarDecl, Function, Decls, Ids, Type,Const, Consts, FuncParams, Types, Body,
    OtherFuncParams, ProcParams,OtherProcParams, ProcParamId, Stat, ProcCall,FunCall, IOArgs, IfStat, WhileStat, Exprs,
    Elif, ProcExprs, Elifs, Expr, Else;



/*PRECEDENZE*/

precedence nonassoc PROCEDURE;

precedence right ASSIGN; // x=y=3 diventa x=(y=3)

precedence left DOLLARSIGN;

precedence left OR;
precedence left AND;

//gli operatori di confronto non hanno associatività (non è possibile fare x<=y<=z)
precedence nonassoc EQ,NE,LT,LE,GT,GE;

precedence left PLUS, MINUS;
precedence left TIMES, DIV;

precedence right NOT;
precedence left UMINUS;


precedence right REF;

precedence left LPAR,RPAR;



  Program ::= Iter Procedure Iter {:RESULT = new ProgramOp :};

  Iter ::= VarDecl Iter
        | Function Iter
        | Procedure Iter
        | /* empty */;

  VarDecl ::= VAR Decls:decls{:RESULT = decls;:};

  Decls ::= Ids:idList COLON Type:type SEMI Decls:declsList
                                      {:
                                        VarDeclOp decl = new VarDeclOp(idList,type);
                                        declsList.add(decl);
                                        RESULT = declsList;
                                      :}
  	| Ids:idList ASSIGN Consts:constList SEMI Decls:declsList
  	                                                   {:
                                                            AssignStatement assignStatement = new AssignStatement(idList,constList);
                                                            for(Expression e : declsList){
                                                                assignStatement.addExpression(e);
                                                            }
                                                            RESULT = assignStatement;
                                                        :}
  	| Ids:idList COLON Type:type SEMI ENDVAR
  	                                {:
                                        RESULT = new VarDeclOp(idList,type);
  	                                :}
  	| Ids:idList ASSIGN Consts:constList SEMI ENDVAR
                                {:
                                    RESULT = new AssignStatement(idList,constList);
                                :}
  	;

  Ids ::= ID:id COMMA Ids:idList
                            {:
                            idList.add(c);
                            RESULT = idList;
                            :}
          | ID:id
          {: ArrayList<Identifier> idList = new ArrayList<Identifier>();
            	            idList.add(c);
            	            RESULT = idList;
            	           :};
//Consts è una lista di espressioni
  Consts ::= Const:c COMMA Consts:constsList
                            {:
                            constsList.add(c);
                            RESULT= constsList;
                            :}
  	| Const:c {: ArrayList<Expression> constsList = new ArrayList<Expression>();
  	            constsList.add(c);
  	            RESULT = constsList;
  	           :};

  Const ::= REAL_CONST  {:RESULT = new Real_const(value); :}
  	| INTEGER_CONST     {:RESULT = new Integer_const(value); :}
  	| STRING_CONST      {:RESULT = new String_const(value); :}
  	| TRUE              {:RESULT = new True_const(); :}
  	| FALSE            {:RESULT = new False_const(); :} ;

  Type ::= REAL {: RESULT = Type.REAL; :}
  	| INTEGER   {: RESULT = Type.INTEGER; :}
  	| STRING    {: RESULT = Type.STRING; :}
  	| BOOLEAN  {: RESULT = Type.BOOL; :};

  Function  ::= FUNCTION:id LPAR FuncParams:params RPAR TYPERETURN Types:types COLON Body:body ENDFUNCTION {:RESULT = new FunctionOp(id,params,types,body); :};

  FuncParams ::= ID:id COLON Type:type OtherFuncParams:params {:
                                                                ProcFunParamOp funParamOp = new ProcFunParamOp(id,type);
                                                                params.add(funParamOp);
                                                                RESULT = params;:}
  	    | /* empty */{:RESULT = new ArrayList<ProcFunParamOp>(); :};

  OtherFuncParams ::= COMMA ID:id COLON Type:type OtherFuncParams:otherParams
                                              {:
                                                ProcFunParamOp funParamOp = new ProcFunParamOp(id,type);
                                                otherParams.add(funParamOp);
                                                RESULT = otherParams;
                                             :}
  	    | /* empty */{:RESULT = new ArrayList<ProcFunParamOp>(); :};

  Types ::= Type:type COMMA Types:typeList {:typeList.add(type);:}
  	| Type:type {: ArrayList<Type> typeList = new ArrayList<Type>();
  	        typeList.add(type);
  	        RESULT = typeList;
  	:};

  Procedure ::= PROCEDURE ID:id LPAR ProcParams:params RPAR COLON Body:body ENDPROCEDURE
  {:  RESULT = new ProcedureOp(id,params,body); :}
  ;

  ProcParams::= ProcParamId:id COLON Type:type OtherProcParams:params
                                      {:ProcFunParamOp procParam = new ProcFunParamOp(id,type);
                                        params.add(procParams);
                                        RESULT = params;
                                       :}
  | /* empty */{:RESULT = new ArrayList<ProcFunParamOp>();:};

  OtherProcParams ::= COMMA ProcParamId:id COLON Type:type OtherProcParams:otherParams
                                       {:ProcFunParamOp procParam = new ProcFunParamOp(id,type);
                                         otherParams.add(procParams);
                                         RESULT = otherParams;
                                       :}
  	   | /* empty */{:RESULT = new ArrayList<ProcFunParamOp>(); :};

  ProcParamId ::= ID:id {: RESULT = new Identifier(id);:}
  	    | OUT ID {:RESULT = new Identifier(id,Qualifier.OUT); :};

  Body ::= VarDecl:vardecl Body:body {:
                                      body.addVarDecl(vardecl);
                                      RESULT = body;
                                      :}
  	| Stat:statement Body:body {:
                                 body.addStatement(statement);
  	                             RESULT = body;
  	                            :}
  	| /* empty */{:RESULT = new BodyOp(); :};

  Stat ::= Ids:idList ASSIGN Exprs:exprList SEMI {: RESULT = new AssignStatement(idList,exprList); :}
  	 | ProcCall:procCall  SEMI {:RESULT = procCall;:}
  	 | RETURN Exprs:exprList SEMI {:RESULT = new ReturnStatement(exprList);:}
  	 | WRITE IOArgs:IOArgsList SEMI {: RESULT = new WriteStatement(WritingType.WRITE, IOArgsList);:}
  	 | WRITERETURN IOArgs:IOArgsList SEMI {: RESULT = new WriteStatement(WritingType.WRITE, IOArgsList);:}
  	 | READ IOArgs:IOArgsList SEMI {: RESULT = new ReadStatement(IOArgsList);:}
  	 | IfStat:ifStat SEMI {:RESULT = ifStat; :}
  	 | WhileStat:whileStat SEMI {:RESULT = whileStat; :} ;

  FunCall ::= ID:id LPAR Exprs:expressions RPAR {: RESULT = new FunCallOp(id,expressions); :}           /* chiamata con almeno un parametro */
           | ID:id LPAR RPAR  {: RESULT = new FunCallOp(id); :};               /* chiamata con nessun parametro */

  ProcCall ::= ID:id LPAR ProcExprs:procedureExpressionList RPAR {: RESULT = new ProcCallOp(id,procedureExpressionList); :}    /* chiamata con almeno un parametro */
           | ID:id LPAR RPAR {: RESULT = new ProcCallOp(id);:};             /* chiamata con nessun parametro */

  IfStat ::= IF Expr:expr THEN Body:body Elifs:elifs Else:elseBody ENDIF
    {: RESULT = new IfStatement(expr, body,elifs,elseBody);  :}
  ;

  Elifs ::= Elif:e Elifs:elifsList {:elifsList.add(e); RESULT = elifsList; :}
        | /* empty */{: RESULT = new ArrayList<ElifOp>(); :};

  Elif ::= ELIF Expr:expr THEN Body:body{:RESULT = new ElifOp(expr,body);:};

  Else ::= ELSE Body:body {:RESULT = new ElseOp(body);:}
       | /* empty */{: RESULT = null; :}
       ;

  WhileStat ::= WHILE Expr:expr DO Body:body ENDWHILE{:RESULT = new WhileStatement(expr,body); :};

  IOArgs ::= Expr:expression IOArgs:IOArgsList {:
                                                IOArg arg = new IOArg(expression,false);
                                                IOArgsList.add(expression);
                                                RESULT = IOARgsList;
                                                :}    /* qui l'Expr corretta è concatenazione di stringhe o singola stringa*/
         |  DOLLARSIGN LPAR Expr:expression RPAR IOArgs:IOArgsList {:
                                                                    IOArg arg = new IOArg(expression,true);
                                                                    IOArgsList.add(expression);
                                                                    RESULT = IOARgsList;
                                                                    :}
         | /* empty */{: RESULT = new ArrayList<IOArg>(); :};

  ProcExprs::= Expr:expression COMMA ProcExprs:procedureExpressions {:
                                                                        ProcedureExpression pe = new ProcedureExpression(expression,false,null);
                                                                        procedureExpressions.add(pe);
                                                                        RESULT = procedureExpressions;
                                                                     :}
  	  | REF ID:id COMMA ProcExprs:procedureExpressions {:
                                                            ProcedureExpression pe = new ProcedureExpression(null,true,id);
  	                                                        procedureExpressions.add(expression);
  	                                                        RESULT = procedureExpressions;
  	                                                    :}
      | Expr:expression {:
                        ArrayList<ProcedureExpression> PEList = new ArrayList<ProcedureExpression>();
                        ProcedureExpression pe = new ProcedureExpression(expression,false,null);
                        PEList.add(pe);
                        RESULT = PEList;
                        :}
  	  | REF ID:id {:
                        ArrayList<ProcedureExpression> PEList = new ArrayList<ProcedureExpression>();
                        ProcedureExpression pe = new ProcedureExpression(null,true,id);
                        PEList.add(pe);
                        RESULT = PEList;
  	               :};

  Exprs ::= Expr:e COMMA Exprs:exprList {: exprList.add(e); RESULT = exprList; :}
  	| Expr:e {: ArrayList<Expression> exprlist = new ArrayList<Expression>();
                exprlist.add(e);
                RESULT = exprList;
  	            :};


  Expr ::= FunCall:funCall        {:RESULT = funCall; :}
  	| REAL_CONST:value    {:RESULT = new Real_const(value); :}
    | INTEGER_CONST:value   {:RESULT = new Integer_const(value); :}
  	| STRING_CONST:value    {:RESULT = new String_const(value); :}
  	| ID:value              {:RESULT = new Identifier(value); :}
    | TRUE                  {:RESULT = new True_const(); :}
    | FALSE                 {:RESULT = new False_const(); :}
    | Expr:e1  PLUS Expr:e2 {:RESULT = new AddOp(e1,e2); :}
  	| Expr:e1  MINUS Expr:e2 {:RESULT = new DiffOp(e1,e2); :}
  	| Expr:e1  TIMES Expr:e2 {:RESULT = new MulOp(e1,e2); :}
  	| Expr:e1  DIV Expr:e2 {:RESULT = new DivOp(e1,e2); :}
  	| Expr:e1  AND Expr:e2 {:RESULT = new AndOp(e1,e2); :}
  	| Expr:e1  OR Expr:e2 {:RESULT = new OrOp(e1,e2); :}
  	| Expr:e1  GT Expr:e2 {:RESULT = new GTOp(e1,e2); :}
  	| Expr:e1  GE Expr:e2 {:RESULT = new GEOp(e1,e2); :}
  	| Expr:e1  LT Expr:e2 {:RESULT = new LTOp(e1,e2); :}
  	| Expr:e1  LE Expr:e2 {:RESULT = new LEOp(e1,e2); :}
  	| Expr:e1  EQ Expr:e2 {:RESULT = new EQOp(e1,e2); :}
  	| Expr:e1  NE Expr:e2 {:RESULT = new NEOp(e1,e2); :}
  	| LPAR Expr:e RPAR {:RESULT = e; :}
  	| MINUS Expr:e {:RESULT = new UminusOp(e); :}
  	    %prec UMINUS
  	| NOT Expr:e {:RESULT = new NotOp(e); :};