/*terminali*/
terminal VAR, COLON, ASSIGN, SEMI, COMMA, REAL, INTEGER, STRING, BOOLEAN, RETURN, FUNCTION, TYPERETURN,
    ENDFUNCTION, LPAR, RPAR, PROCEDURE, ENDPROCEDURE, OUT, WRITE, WRITERETURN, DOLLARSIGN, READ, IF, THEN, ELSE, ENDIF,
    ELIF, WHILE, DO, ENDWHILE, PLUS, MINUS, TIMES, DIV, EQ, NE, LT, LE, GT, GE, AND, OR, NOT, ENDVAR, REF, UMINUS;

terminal String ID, STRING_CONST;
terminal Double REAL_CONST;
terminal Integer INTEGER_CONST;
terminal Boolean TRUE, FALSE;

/*non terminali*/
non terminal Program, Iter, Procedure, VarDecl, Function, Decls, Ids, Type,Const, Consts, FuncParams, Types, Body,
    OtherFuncParams, ProcParams,OtherProcParams, ProcParamId, Stat, ProcCall,FunCall, IOArgs, IfStat, WhileStat, Exprs,
    Elif, ProcExprs, Elifs, Expr, Else;



/*PRECEDENZE*/

precedence nonassoc PROCEDURE;

precedence right ASSIGN; // x=y=3 diventa x=(y=3)

precedence left DOLLARSIGN;

precedence left OR;
precedence left AND;

//gli operatori di confronto non hanno associatività (non è possibile fare x<=y<=z)
precedence nonassoc EQ,NE,LT,LE,GT,GE;

precedence left PLUS, MINUS;
precedence left TIMES, DIV;

precedence right NOT;
precedence left UMINUS;


precedence right REF;

precedence left LPAR,RPAR;



  Program ::= Iter Procedure Iter {:RESULT = new ProgramOp :};

  Iter ::= VarDecl Iter
        | Function Iter
        | Procedure Iter
        | /* empty */;

  VarDecl ::= VAR Decls;

  Decls ::= Ids:id COLON Type SEMI Decls
  	| Ids:id ASSIGN Consts SEMI Decls
  	| Ids:id COLON Type SEMI ENDVAR
  	| Ids:id ASSIGN Consts SEMI ENDVAR;

  Ids ::= ID COMMA Ids
          | ID;

  Consts ::= Const COMMA Consts
  	| Const;

  Const ::= REAL_CONST  {:RESULT = new Real_const(value); :}
  	| INTEGER_CONST     {:RESULT = new Integer_const(value); :}
  	| STRING_CONST      {:RESULT = new String_const(value); :}
  	| TRUE              {:RESULT = new True_const(); :}
  	| FALSE            {:RESULT = new False_const(); :} ;

  Type ::= REAL {: RESULT = Type.REAL; :}
  	| INTEGER   {: RESULT = Type.INTEGER; :}
  	| STRING    {: RESULT = Type.STRING; :}
  	| BOOLEAN  {: RESULT = Type.BOOL; :};

  Function  ::= FUNCTION:id LPAR FuncParams:params RPAR TYPERETURN Types:types COLON Body:body ENDFUNCTION {:RESULT = new FunctionOp(id,params,types,body); :};

  FuncParams ::= ID:id COLON Type:type OtherFuncParams:params {: RESULT = :}
  	    | /* empty */{:RESULT = null; :};

  OtherFuncParams ::= COMMA ID COLON Type OtherFuncParams
  	    | /* empty */{:RESULT = null; :};

  Types ::= Type:type COMMA Types:typeList {:typeList.add(type);:}
  	| Type:type {: ArrayList<Type> typeList = new ArrayList<Type>();
  	        typeList.add(type);
  	        RESULT = typeList;
  	:};

  Procedure ::= PROCEDURE ID:id LPAR ProcParams:params RPAR COLON Body:body ENDPROCEDURE
  {:  RESULT = new ProcedureOp(id,params,body); :}
  ;

  ProcParams::= ProcParamId:id COLON Type:type OtherProcParams:params {: RESULT = new ProcFunParamOp(null,id);:}
  	   | /* empty */{:RESULT = null; :};

  OtherProcParams ::= COMMA ProcParamId:id COLON Type:type OtherProcParams:params {::}
  	   | /* empty */{:RESULT = null; :};

  ProcParamId ::= ID
  	    | OUT ID;

  Body ::= VarDecl:vardecl Body:body {:RESULT :}
  	| Stat:statements Body:body {: RESULT = new BodyOp(null,statements); :}
  	| /* empty */{:RESULT = null; :};

  Stat ::= Ids:idList ASSIGN Exprs:exprList SEMI {: RESULT = new AssignStatement(idList,exprList); :}
  	 | ProcCall  SEMI
  	 | RETURN Exprs:exprList SEMI {:RESULT = new ReturnStatement(exprList);:}
  	 | WRITE IOArgs SEMI
  	 | WRITERETURN IOArgs SEMI
  	 | READ IOArgs SEMI
  	 | IfStat:ifStat SEMI {:RESULT = ifStat; :}
  	 | WhileStat:whileStat SEMI {:RESULT = whileStat; :} ;

  FunCall ::= ID:id LPAR Exprs:expressions RPAR {: RESULT = new FunCallOp(id,expressions); :}           /* chiamata con almeno un parametro */
           | ID LPAR RPAR  {: RESULT = new FunCallOp(id,null); :};               /* chiamata con nessun parametro */

  ProcCall ::= ID LPAR ProcExprs RPAR    /* chiamata con almeno un parametro */
           | ID LPAR RPAR;             /* chiamata con nessun parametro */

  IfStat ::= IF Expr:expr THEN Body:body Elifs:elifs Else:elseBody ENDIF
    {: RESULT = new IfStatement(expr, body,elifs,elseBody);  :}
  ;

  Elifs ::= Elif:e Elifs:elifsList {:elifsList.add(e); RESULT = elifsList; :}
        | /* empty */{: RESULT = null; :};

  Elif ::= ELIF Expr:expr THEN Body:body{:RESULT = new ElifOp(expr,body);:};

  Else ::= ELSE Body
       | /* empty */;

  WhileStat ::= WHILE Expr:expr DO Body:body ENDWHILE{:RESULT = new WhileStatement(expr,body); :};

  IOArgs ::= Expr IOArgs    /* qui l'Expr corretta è concatenazione di stringhe o singola stringa*/
         |  DOLLARSIGN LPAR Expr RPAR IOArgs
         | /* empty */;

  ProcExprs::= Expr COMMA ProcExprs
  	  | REF ID COMMA ProcExprs
      | Expr
  	  | REF ID;

  Exprs ::= Expr:e COMMA Exprs:exprList {: exprList.add(e); RESULT = exprList; :}
  	| Expr:e {: ArrayList<Expression> exprlist = new ArrayList<Expression>();
                exprlist.add(e);
                RESULT = exprList;
  	            :};


  Expr ::= FunCall
  	| REAL_CONST:value    {:RESULT = new Real_const(value); :}
    | INTEGER_CONST:value   {:RESULT = new Integer_const(value); :}
  	| STRING_CONST:value    {:RESULT = new String_const(value); :}
  	| ID:value              {:RESULT = new Identifier(value); :}
    | TRUE                  {:RESULT = new True_const(); :}
    | FALSE                 {:RESULT = new False_const(); :}
    | Expr:e1  PLUS Expr:e2 {:RESULT = new AddOp(e1,e2); :}
  	| Expr:e1  MINUS Expr:e2 {:RESULT = new DiffOp(e1,e2); :}
  	| Expr:e1  TIMES Expr:e2 {:RESULT = new MulOp(e1,e2); :}
  	| Expr:e1  DIV Expr:e2 {:RESULT = new DivOp(e1,e2); :}
  	| Expr:e1  AND Expr:e2 {:RESULT = new AndOp(e1,e2); :}
  	| Expr:e1  OR Expr:e2 {:RESULT = new OrOp(e1,e2); :}
  	| Expr:e1  GT Expr:e2 {:RESULT = new GTOp(e1,e2); :}
  	| Expr:e1  GE Expr:e2 {:RESULT = new GEOp(e1,e2); :}
  	| Expr:e1  LT Expr:e2 {:RESULT = new LTOp(e1,e2); :}
  	| Expr:e1  LE Expr:e2 {:RESULT = new LEOp(e1,e2); :}
  	| Expr:e1  EQ Expr:e2 {:RESULT = new EQOp(e1,e2); :}
  	| Expr:e1  NE Expr:e2 {:RESULT = new NEOp(e1,e2); :}
  	| LPAR Expr:e RPAR {:RESULT = e; :}
  	| MINUS Expr:e {:RESULT = new UminusOp(e); :}
  	    %prec UMINUS
  	| NOT Expr:e {:RESULT = new NotOp(e); :};